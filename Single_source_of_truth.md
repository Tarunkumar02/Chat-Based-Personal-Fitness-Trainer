# Single Source of Truth — Chat-Based Personal Fitness Trainer (MERN)

> Authoritative project guide for developers and AI agents building the Chat-Based Personal Fitness Trainer (MERN). This document contains the data model, API contracts, user flows, data flows, Gemini integration spec, folder structure, run instructions, and demo script.

---

## 1. Project Overview

**Goal:** Build a MERN app with a chat UI that uses Google Gemini to generate personalized workout plans and nutrition tips. Users sign up with email/password, complete onboarding (age, height, weight, goals, diet), chat for on-demand plan generation, log workouts and progress, and visualize progress on a combo chart.

**Primary features:**

* Auth (email/password)
* Onboarding & editable profile
* Chat interface (fitness-only)
* Gemini integration returning structured JSON plans
* Store user profiles, logs, and generated JSON plans in MongoDB
* Workout logging (detailed + simple)
* Progress tracking (weight, workouts, calories)
* Combo chart (weight + workouts + calories) using Recharts
* Rate limiting for the chat API

**Tech stack:**

* Frontend: React.js, Recharts, Axios
* Backend: Node.js, Express.js
* Database: MongoDB (Mongoose)
* LLM: Google Gemini API
* Repo layout: Monorepo (client + server)
* Language: JavaScript (no TypeScript)

---

## 2. High-level Architecture

1. **Client (React)**

   * UI components: Auth, Onboarding, Chat, Dashboard, Profile, Workout Log
   * Communicates with backend over RESTful API + WebSockets (optional for live streaming)
2. **Server (Express)**

   * Auth endpoints (JWT)
   * CRUD for profile, workouts, progress
   * `/chat` endpoint that proxies requests to Gemini with system prompts and returns/validates structured JSON
   * Rate limiter middleware on chat route
3. **MongoDB**

   * Stores users, profiles, goals, generated plans (JSON), workout logs, progress entries, chat histories
4. **Gemini**

   * Called from backend. System prompt instructs Gemini to return a strict JSON schema. Backend validates and stores generated plan JSON and returns a friendly message to the client.

Data flows: User ↔ Client ↔ Server ↔ Gemini; Server ↔ MongoDB

---

## 3. Important Non-functional Requirements

* Rate limiting on chat: per-user (e.g., 60 requests/hour) using token-bucket or `express-rate-limit`.
* Basic error handling on backend (consistent error response format).
* Validation of Gemini JSON before storing or showing to users.
* Keep no long-term storage of raw Gemini text if policy requires; store validated JSON plan objects.

---

## 4. Database Models (Mongoose Schemas)

Below are canonical schema definitions (JS, Mongoose-style) — adapt to your code.

### `User` (auth + profile fields)

```js
const UserSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true, index: true },
  passwordHash: { type: String, required: true },
  createdAt: { type: Date, default: Date.now },
  // Onboarding/profile fields
  profile: {
    firstName: { type: String },
    lastName: { type: String },
    age: { type: Number },
    gender: { type: String },
    heightCm: { type: Number },
    weightKg: { type: Number },
    activityLevel: { type: String }, // sedentary, light, moderate, active
    goals: [{ type: String }], // weight loss, muscle gain, endurance, etc.
    dietaryPreferences: {
      type: { type: String }, // veg/non-veg/vegan
      allergies: [String],
      preferencesNotes: String
    },
    fitnessLevel: { type: String }, // beginner/intermediate/advanced
    updatedAt: { type: Date, default: Date.now }
  },
  settings: { // UI settings, units
    units: { type: String, default: 'metric' }
  }
});
```

### `Plan` (generated by Gemini — stored as JSON blob + metadata)

```js
const PlanSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', index: true },
  source: { type: String, default: 'gemini' },
  promptSnapshot: { type: String },
  planJSON: { type: Object, required: true },
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date }
});
```

### `WorkoutLog` (each user can add many)

```js
const WorkoutLogSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', index: true },
  date: { type: Date, required: true },
  durationMinutes: Number,
  type: String, // 'strength' | 'cardio' | 'yoga' | custom
  exercises: [
    {
      name: String,
      sets: Number,
      reps: Number,
      weightKg: Number,
      durationSec: Number,
      notes: String
    }
  ],
  caloriesBurned: Number,
  createdAt: { type: Date, default: Date.now }
});
```

### `ProgressEntry` (for charting metrics like weight and calories)

```js
const ProgressEntrySchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', index: true },
  date: { type: Date, required: true },
  weightKg: Number,
  caloriesConsumed: Number,
  caloriesBurned: Number,
  notes: String,
  createdAt: { type: Date, default: Date.now }
});
```

### `ChatMessage` (store chat history per user)

```js
const ChatMessageSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', index: true },
  role: { type: String, enum: ['user','assistant','system'], required: true },
  content: { type: String },
  metadata: { type: Object },
  createdAt: { type: Date, default: Date.now }
});
```

> Index notes: index `userId` and `date` where queries are time-bounded.

---

## 5. API Specification (REST)

Authenticate with JWT. All protected routes require `Authorization: Bearer <token>`.

Base URL: `/api`

### Auth

* `POST /api/auth/register`

  * Body: `{ email, password }`
  * Response: `{ ok: true }` (plus email verification step optional)
* `POST /api/auth/login`

  * Body: `{ email, password }`
  * Response: `{ token, user: { id, email, profile } }`

### Onboarding / Profile

* `GET /api/profile` -> returns user profile
* `PUT /api/profile` -> update onboarding/profile

  * Body: e.g. `{ firstName, age, heightCm, weightKg, goals: [], dietaryPreferences: {} }`

### Chat & Plans

* `POST /api/chat` (main route)

  * Body: `{ message: 'I want a 4-week strength plan', context?: {} }`
  * Server actions:

    1. Check rate limit per user
    2. Create ChatMessage (user)
    3. Build system prompt (includes user profile snapshot)
    4. Call Gemini, expect structured JSON
    5. Validate JSON, store Plan doc, create ChatMessage (assistant)
  * Response: `{ success: true, assistantText, planId (if applicable), planJSON }`

* `GET /api/plans` -> list user plans

* `GET /api/plans/:id` -> retrieve plan JSON

### Workout Logs

* `POST /api/workouts` -> create workout log
* `GET /api/workouts?from=&to=` -> list logs

### Progress

* `POST /api/progress` -> add a progress entry (weight/calories)
* `GET /api/progress?from=&to=` -> returns entries for charts

### Chat History

* `GET /api/chat/history?limit=50` -> last N messages

### Error format

All errors return `{ ok: false, error: { code: 'string', message: 'user friendly' } }` and appropriate HTTP status codes.

---

## 6. Gemini Integration Spec (System Prompts & Expected JSON)

**Design principle:** Ask Gemini to return JSON only, using a clear `response_schema` block. Backend must validate schema before storing. Use short system message, include user profile snapshot.

### Example System Prompt (backend constructs dynamically)

```
SYSTEM:
You are FitGenie, a personal fitness assistant. You must respond only with valid JSON following the EXACT schema described below. Do not output any explanatory text outside JSON.

SCHEMA_VERSION: 1.0
{
  "plan": {
    "type": "string",           // e.g., "4-week strength plan"
    "durationWeeks": "number",
    "workoutDaysPerWeek": "number",
    "exercises": [
      {
        "day": "string",       // e.g., "Day 1"
        "exercises": [
          {
            "name": "string",
            "category": "string", // strength/cardio
            "sets": "number?",
            "reps": "string?",   // "8-12"
            "weightKg": "number?",
            "durationSec": "number?",
            "tempo": "string?",
            "restSeconds": "number?",
            "equipment": "string?",
            "notes": "string?"
          }
        ]
      }
    ]
  },
  "nutrition": {
    "dailyCalories": "number",
    "macros": { "proteinG": "number", "carbsG": "number", "fatG": "number" },
    "meals": [ { "name": "string", "items": ["string"], "calories": "number" } ]
  },
  "rationale": "string",
  "warnings": ["string"]
}

CONTEXT: include the following user details: age, gender, heightCm, weightKg, activityLevel, goals, dietary preferences. Generate practical exercises available with bodyweight + common equipment. Keep exercises safe and suitable for the user fitness level.

Return only JSON that matches the schema. If something is unknown, fill with sensible defaults.
```

> Backend must wrap user data into the prompt, but must limit private data exposure per privacy policy.

### JSON Validation

* Use `ajv` or manual validators to verify required fields and types.
* If Gemini returns text that cannot be parsed as JSON, retry a limited number of times (2) and fallback to a friendly error.

---

## 7. Backend Implementation Notes (Express)

* Use `express.json()` and helmet, cors.
* Auth: `bcrypt` for hashing, `jsonwebtoken` for tokens.
* Rate limiting: `express-rate-limit` middleware scoped to chat route:

```js
const chatLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 60, // 60 requests per hour per IP or user
  keyGenerator: (req) => req.user.id // rate-limit per user
});
app.post('/api/chat', authenticate, chatLimiter, chatHandler);
```

* Gemini call: wrap into `services/geminiService.js`. Store `process.env.GEMINI_API_KEY`.
* Validation: `services/planValidator.js` using `ajv`.

---

## 8. Frontend Design (React)

### State management

* Use React Context + Reducer for auth and user state.
* Keep chat state local to Chat component; persist messages to backend and rehydrate from `GET /api/chat/history`.

### Key components

* `Auth/` – Login form, Register form
* `Onboarding/` – Stepper: Basic info -> Goals -> Diet -> Finish
* `Chat/` – Chat window, message composer, send button; show assistant messages with "View Plan" button if JSON plan returned.
* `Dashboard/` – Summary cards (current weight, weekly workouts, active plan) + Combo chart
* `Profile/` – Editable profile
* `WorkoutLog/` – Add workout modal (detailed and simple)
* `Charts/ComboChart.jsx` – Recharts implementation

### Combo Chart data shape (for Recharts)

The chart will display 3 series on a single x-axis (date):

* weight (line)
* workouts count per day (bar)
* calories burned (line or area)

Sample data:

```js
const chartData = [
  { date: '2026-01-01', weightKg: 80, workouts: 1, caloriesBurned: 300 },
  { date: '2026-01-02', weightKg: 79.8, workouts: 0, caloriesBurned: 0 },
  // ...
];
```

Recharts: Use a `ComposedChart` with `Line` for `weightKg`, `Bar` for `workouts`, and `Area` for `caloriesBurned`. Convert units in UI if user selected imperial.

---

## 9. Folder Structure (Monorepo)

```
/ (root)
  /client
    /public
    /src
      /components
      /pages
      /contexts
      /services (api wrappers)
      /charts
      App.jsx
      index.jsx
    package.json
  /server
    /controllers
    /models
    /routes
    /services (gemini, validations)
    /middleware (auth, rateLimit)
    server.js
    package.json
  package.json (workspace)
  README.md
  .env.example
```

---

## 10. Environment Variables (.env.example)

```
# Server
MONGO_URI=mongodb://localhost:27017/fitness
JWT_SECRET=replace_this_with_strong_secret
GEMINI_API_KEY=your_gemini_key_here
PORT=4000

# Client
REACT_APP_API_BASE_URL=http://localhost:4000/api
```

---

## 11. Security & Privacy

* Hash passwords with bcrypt (saltRounds 10+).
* Use HTTPS in production; local dev can use HTTP.
* Keep Gemini key secret on server; never expose to client.
* Only store validated structured JSON from Gemini.
* Implement CORS for client origin.

---

## 12. Error Handling & Logging

* Standardize response: `{ ok: boolean, data?: any, error?: { code, message } }`.
* Log errors server-side (winston or simple console). Protect logs from sensitive data.
* On Gemini errors: return `error.code='LLM_FAILURE'` and user-friendly message.

---

## 13. Rate Limiting Policy (detailed)

* **Scope:** chat endpoint
* **Policy:** 60 requests per user per hour; burst allowed up to 10 within a minute.
* Implementation: `express-rate-limit` with `keyGenerator: req.user.id` or custom token bucket in Redis for scalable setups.

---

## 14. Testing & Demo Guide

* Unit tests: validate Mongoose models and API contract (Jest + Supertest).
* Manual demo flow (for README / portfolio):

  1. Register user
  2. Complete onboarding
  3. Open Chat and send: "Create a 4-week beginner strength plan for me."
  4. Backend calls Gemini and returns plan JSON; UI displays plan and stores plan in `Plans` list.
  5. Log a couple workouts and progress entries.
  6. Open Dashboard and capture combo chart screenshot.

**Demo Chat Example (sample request & expected JSON):**

**User message:**

```
Create a 4-week beginner strength plan focused on compound lifts. I have a pair of dumbbells and can train 3 days/week. Also suggest daily meal ideas for 2000 kcal.
```

**Expected Gemini JSON (trimmed):**

```json
{
  "plan": {
    "type": "4-week strength",
    "durationWeeks": 4,
    "workoutDaysPerWeek": 3,
    "exercises": [
      { "day": "Day 1", "exercises": [ { "name": "Goblet Squat", "sets": 3, "reps": "8-12", "equipment": "dumbbell" } ] },
      { "day": "Day 2", "exercises": [ { "name": "Dumbbell Bench Press", "sets": 3, "reps": "8-12" } ] }
    ]
  },
  "nutrition": {
    "dailyCalories": 2000,
    "macros": { "proteinG": 140, "carbsG": 230, "fatG": 60 },
    "meals": [ { "name": "Breakfast", "items": ["Oats + Milk + Banana"], "calories": 500 } ]
  },
  "rationale": "Focus on progressive overload and compound movements.",
  "warnings": ["Consult physician if you have medical issues"]
}
```

---

## 15. Run Instructions (developer setup)

### Prereqs

* Node.js (v18+)
* MongoDB running locally or remote connection

### Quick start (root monorepo)

```bash
# At project root
cd server
npm install
cp .env.example .env  # then edit
npm run dev        # uses nodemon – server on PORT

cd ../client
npm install
npm start          # React dev server
```

Common helper scripts (add to server/package.json):

```json
"scripts": {
  "start": "node server.js",
  "dev": "nodemon server.js"
}
```

Client `package.json` should contain start script (`react-scripts start` or Vite). Adjust accordingly.

---

## 16. Conventions & Coding Guidance

* JS only: use modern ES modules where possible but keep consistency (CommonJS on server is fine).
* Naming: `camelCase` for JS variables; `PascalCase` for React components.
* API versioning: prefix with `/api` and consider `/v1` later.
* Commit messages: `feat:`, `fix:`, `chore:`.

---

## 17. Milestones & Task List (Suggested)

1. Project scaffolding: monorepo, server and client basics
2. Auth and onboarding flows
3. Mongoose models and basic CRUD
4. Chat endpoint + Gemini service + JSON validation
5. Store Plan and ChatMessage
6. Workout log + progress endpoints
7. Dashboard + Combo chart
8. Rate limiting and basic error handling
9. Demo and README

---

## 18. Troubleshooting Tips

* If Gemini responses are free text: increase strictness of system prompt and add explicit `You MUST output ONLY JSON` instruction; then validate and if parsing fails apply a second attempt.
* If chart data looks sparse: aggregate workouts by `date` on server before returning to client.

---

## 19. Example API Request/Response (Chat)

**Request**

```
POST /api/chat
Headers: Authorization: Bearer <token>
Body: { "message": "Create a 3-week cardio and strength plan for weight loss." }
```

**Response**

```json
{
  "ok": true,
  "assistantText": "Here's a 3-week plan. Click 'View plan' to inspect the structured plan.",
  "planId": "63a...",
  "planJSON": { /* validated JSON */ }
}
```

---

## 20. Deliverables Checklist (for README)

* [ ] GitHub repo with monorepo code
* [ ] Clear README + run instructions
* [ ] Demo chat session (video or step-by-step) — include the user message and the returned JSON plan
* [ ] Combo chart screenshot (weight + workouts + calories)

---

## Appendix A: Minimal Example — Gemini service pseudocode (server/services/geminiService.js)

```js
async function callGemini(prompt, apiKey){
  const res = await fetch('https://api.gemini.example/v1/generate', {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
    body: JSON.stringify({ prompt, maxTokens: 1200 })
  });
  const text = await res.text();
  try { return JSON.parse(text); } catch(e) { throw new Error('Invalid LLM JSON'); }
}
```